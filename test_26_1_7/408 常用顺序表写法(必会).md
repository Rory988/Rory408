## 0）先统一：408 常用顺序表写法（1 下标 + 哨兵）

插入排序用了 **A[0] 当哨兵**，好处是循环里不用反复判断边界。
       下面所有排序默认：有效元素是 `A[1..n]`，`A[0]` 只在插入类里当临时变量/哨兵。

```c
// 交换（通用）
static inline void swap(int *x, int *y){
    int t = *x; *x = *y; *y = t;
}
```

## 1）插入类

### 1.1 直接插入排序（带哨兵，必会）

要点：`A[0]=A[i]` 暂存；从后往前挪；最后放回。带哨兵的优点：不用每轮都判断 j 是否越界。8.2.1+8.2.2 插入排序

```c
// 直接插入排序（A[1..n]，A[0]作哨兵）
void InsertSort(int A[], int n){
    for(int i = 2; i <= n; i++){
        if(A[i] < A[i-1]){
            A[0] = A[i];          // 哨兵/暂存待插入元素
            int j = i - 1;
            while(A[0] < A[j]){   // 不用写 j>=1 的边界判断（靠A[0]停）
                A[j+1] = A[j];    // 元素后移
                j--;
            }
            A[j+1] = A[0];        // 插入
        }
    }
}
```

需要记住的结论：空间 O(1)，最好 O(n)，最坏/平均 O(n²)，**稳定**。

### 1.2 折半插入排序（必会）

- 先折半找位置，再整体右移。
- 为了稳定：当 `A[mid]==A[0]` 时，应继续往 **右边** 找插入位置。
- 当 `low>high` 停止，把 `[low..i-1]` 右移，然后 `A[low]=A[0]`。

```c
// 折半插入排序（A[1..n]，A[0]作哨兵）
void BinaryInsertSort(int A[], int n){
    for(int i = 2; i <= n; i++){
        A[0] = A[i];                 // 待插入元素
        int low = 1, high = i - 1;
        while(low <= high){
            int mid = (low + high) / 2;
            if(A[mid] > A[0]) high = mid - 1;
            else low = mid + 1;      // == 时继续向右，保证稳定性（插到相等元素后面）
        }
        // 此时 low 为插入位置：把[low..i-1]整体右移
        for(int j = i - 1; j >= low; j--) A[j+1] = A[j];
        A[low] = A[0];
    }
}
```



### 1.3 希尔排序（会写增量版模板即可）

最坏 O(n²)，空间 O(1)，**不稳定**，且“仅适用于顺序表，不适用于链表”。

```c
// 希尔排序（最常见增量：d = n/2, d/=2）
void ShellSort(int A[], int n){
    for(int d = n/2; d >= 1; d /= 2){
        // 对每个“间隔为d”的子序列做直接插入
        for(int i = d + 1; i <= n; i++){
            if(A[i] < A[i-d]){
                A[0] = A[i];
                int j = i - d;
                while(j >= 1 && A[0] < A[j]){
                    A[j+d] = A[j];
                    j -= d;
                }
                A[j+d] = A[0];
            }
        }
    }
}
```

