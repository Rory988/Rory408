## 7）外部排序（408：一般“理解流程 + 会写败者树骨架”）

> 外部排序：数据太多不能一次进内存；用归并思想，最少 3 块缓冲区（2 输入+1 输出）

### 7.1 k 路归并的“败者树”（建议会写：数组 + adjust）

> “k 路归并的败者树只需要定义一个长度为 k 的数组” 

```c
// loser tree：ls[0..k-1] 存“失败者下标”，winner 通过 ls[0] 或单独变量得到（不同教材实现略有差异）

#define INF 0x3f3f3f3f

int k;
int ls[128];      // 败者树
int key[128];     // 每路当前元素（用来比较）

int winner(int a, int b){    // 返回更小者下标（做最小归并）
    return (key[a] <= key[b]) ? a : b;
}

void LT_Init(){
    for(int i=0;i<k;i++) ls[i] = -1;
    // 逐个“插入”构建：等价于第一次构造要比较 k-1 次（PPT结论）:contentReference[oaicite:14]{index=14}
    for(int i=0;i<k;i++){
        int t=i, p=(i+k)/2;
        while(p>0){
            if(ls[p]==-1){ ls[p]=t; break; }
            int w = winner(t, ls[p]);
            int l = (w==t)? ls[p] : t;
            ls[p]=l;
            t=w;
            p/=2;
        }
        ls[0]=t; // 根记录当前胜者（常见写法之一）
    }
}

// 当某一路 key[s] 更新后，重新调整
void LT_Adjust(int s){
    int t=s, p=(s+k)/2;
    while(p>0){
        int w = winner(t, ls[p]);
        int l = (w==t)? ls[p] : t;
        ls[p]=l;
        t=w;
        p/=2;
    }
    ls[0]=t;
}
```

### 7.2 置换-选择排序（生成更长初始归并段：了解即可）

> 思路：工作区 WA 满了就选最小输出；如果新读入元素破坏当前段就“冻结”放到下一段（PPT在讲“构造初始归并段”的改进）
>  （408通常不要求你完整手写工程代码，记住：**用小根堆 + 冻结标记**生成 run。）

### 7.3 最佳归并树（了解：用哈夫曼/最小堆算 WPL）

> 最佳归并树 = 类哈夫曼，目标是最小 WPL 

```c
// 给定各归并段长度 w[i]，最小化总合并代价：反复取最小两段相加再放回
long long OptimalMergeCost(int w[], int m){
    // 408可用“最小堆”写，这里只给伪代码思路：push all; while(size>1){a=pop;b=pop;cost+=a+b;push(a+b);}
    return 0;
}
```



