## 2. 交换类

### 2.1 冒泡排序（带提前结束标志，必会）

相邻逆序就交换，总共 n-1 趟；如果某一趟**没有交换**，说明整体已有序，可以提前结束。
 	稳定性理由：只有 `A[j-1] > A[j]` 才交换，所以稳定。
	 复杂度：空间 O(1)；最好 O(n)，最坏/平均 O(n²)。

```C
void BubbleSort(int A[], int n){
    for(int i = 1; i <= n - 1; i++){
        int swapped = 0;
        for(int j = n; j >= i + 1; j--){
            if(A[j-1] > A[j]){
                swap(&A[j-1], &A[j]);
                swapped = 1;
            }
        }
        if(!swapped) break; // 一趟无交换 => 已整体有序
    }
}
```

------

### 2.2 快速排序（Partition + 递归，必会）

选 pivot（通常首元素），一趟“划分”成 `< pivot` 和 `>= pivot` 两部分，再对两边递归。
 复杂度结论：最好/平均 O(nlogn)，最坏 O(n²)；空间 O(递归层数)，最好 O(logn)，最坏 O(n)。

```c
// 一次划分：返回枢轴最终位置
int Partition(int A[], int low, int high){
    int pivot = A[low];            // 常见：取首元素为枢轴
    while(low < high){
        while(low < high && A[high] >= pivot) high--;
        A[low] = A[high];          // 把小的填到左边坑
        while(low < high && A[low] <= pivot) low++;
        A[high] = A[low];          // 把大的填到右边坑
    }
    A[low] = pivot;
    return low;
}

void QuickSort(int A[], int low, int high){
    if(low < high){
        int p = Partition(A, low, high);
        QuickSort(A, low, p - 1);
        QuickSort(A, p + 1, high);
    }
}

// 调用：QuickSort(A, 1, n);
```

> 提到枢轴可优化（如三数取中/随机），但 408 手写通常先掌握上面这个基础版即可。

------

## 3）选择类

### 3.1 简单选择排序（必会）

无论序列是否有序，都要 n-1 趟；比较次数固定；空间 O(1)，时间 O(n²)，**不稳定**；既可用于顺序表也可用于链表。

```c
void SelectSort(int A[], int n){
    for(int i = 1; i <= n - 1; i++){
        int min = i;
        for(int j = i + 1; j <= n; j++){
            if(A[j] < A[min]) min = j;
        }
        if(min != i) swap(&A[i], &A[min]);
    }
}
```

------

### 3.2 堆排序（建堆 + 下坠调整，必会）

- 大根堆性质：`L(i) ≥ L(2i)` 且 `L(i) ≥ L(2i+1)`。
- 顺序存储下标关系：左孩子 `2i`，右孩子 `2i+1`，父节点 `i/2`。
- 堆排序每趟：把堆顶加入有序序列（与最后一个元素交换），再把堆调整回大根堆（小元素下坠）。
- 时间复杂度：建堆 O(n)，整体 O(nlogn)；空间 O(1)。
- 稳定性：PPT 专门给了“稳定性”示例（结论为不稳定）。

```c
// 将以k为根的子树调整为大根堆（下坠），len为当前堆大小
void HeapAdjust(int A[], int k, int len){
    A[0] = A[k];                // 暂存根
    for(int i = 2*k; i <= len; i = 2*i){  // i 指向k的左孩子
        if(i < len && A[i] < A[i+1]) i++; // 选更大的孩子
        if(A[0] >= A[i]) break;           // 根已比孩子大，结束
        A[k] = A[i];                      // 孩子上移
        k = i;                            // 继续向下
    }
    A[k] = A[0];                          // 放回根
}

void BuildMaxHeap(int A[], int n){
    for(int i = n/2; i >= 1; i--)         // 从最后一个非叶子结点开始
        HeapAdjust(A, i, n);
}

void HeapSort(int A[], int n){
    BuildMaxHeap(A, n);
    for(int i = n; i >= 2; i--){
        swap(&A[1], &A[i]);               // 堆顶(最大)放到末尾
        HeapAdjust(A, 1, i - 1);          // 剩余部分恢复大根堆
    }
}
```