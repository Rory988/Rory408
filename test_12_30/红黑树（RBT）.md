# 红黑树（RBT）

## 1. 基础：红黑树是什么？
![image-20251230225000854](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251230225000854.png)

红黑树 = **二叉排序树（BST）+ 颜色约束**  
BST性质：`左子树结点值 ≤ 根结点值 ≤ 右子树结点值`

### 1.1 五条性质（记忆口诀）
1) 每个结点非红即黑  
2) **根结点是黑色**  
3) 所有叶子（NULL/外部结点）都是黑色  
4) **不允许红红相邻**（红结点的父/子都必须是黑）  
5) **黑路同**：对任一结点，从该结点到任一NULL叶子的路径上，黑结点数相同  

> 口诀：**左根右，根叶黑，不红红，黑路同**

---

## 2. 补充概念：黑高 bh（Black Height）
![image-20251230224550055](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251230224550055.png)

要理解这个红黑树的黑高推论，核心是先搞懂黑高（bh）的定义，再看“内部结点数最少”的本质，用“台阶”和“树的形态”来通俗解释：

第一步：先搞懂「黑高（bh）」是啥

黑高的定义：从某个节点出发（不算这个节点自己），走到任意一个叶子（图里的NULL空节点）的路径上，黑色节点的总数。
举个例子：

• 图里根节点6的bh=2，就是从6往下走到NULL的路径上，能数出2个黑色节点；

• 节点2的bh=1，从2往下走到NULL，只能数出1个黑色节点。
你可以把黑高理解成“从这个节点往下走，要踩过的黑色台阶数”，而且不管走哪条路，黑色台阶数都一样（红黑树的核心性质）。

第二步：理解「根节点黑高为h，内部结点数最少有2^h -1个」

这个结论的关键是“最少”二字，想让内部节点数量最少，就得让红黑树里没有红色节点（红色节点是“额外节点”，加了会让总数变多），只保留黑色节点，形成纯黑的满二叉树（满二叉树是最“紧凑”的树，节点数最少且结构对称）。

用“满二叉树”套公式就好懂了：

满二叉树的特点是：每一层的节点都满了，没有空缺。高度为h的满二叉树，总节点数是2^h -1（这是数据结构里的基础结论）。
而红黑树里“根节点黑高为h”且“节点最少”时，这棵树就是高度为h的纯黑满二叉树（因为黑高h就对应满二叉树的高度h）：

• 图里根黑高=2：纯黑满二叉树高度为2，节点数=2²-1=3，对应中间的图，正好3个黑色节点；

• 图里根黑高=3：纯黑满二叉树高度为3，节点数=2³-1=7，对应右边的图，正好7个黑色节点。

一句话总结

黑高就是“往下走的黑色台阶数”，想让节点最少就只留黑节点凑成满二叉树，满二叉树的节点数公式是2^h -1，这里的h就是根的黑高。

需要我用具体的数字例子（比如根黑高=4）帮你算一遍最少节点数，并画个简易的树结构示意图吗？这样能更直观看到规律～

### 2.2 通俗理解（台阶法）

把“黑结点”当成**黑色台阶**：  
从某结点往下走到NULL，必须踩过的黑台阶数 = bh。  
而且不管走哪条路，黑台阶数都一样（对应“黑路同”）。

3. 黑高相关推论：根黑高为 h，内部结点最少多少？

### 3.1 结论
若**根节点黑高为 h**，则内部结点数（关键字）**最少**为：
\[
n_{\min}=2^h-1
\]

### 3.2 为什么（抓住“最少”二字）
要让结点数最少，就要让树“最紧凑”：
- 红结点是“额外插层”，会让结点数更多  
- 所以最少情况：**尽量不出现红结点**，只保留黑结点
- 形成 **h 层黑结点的满二叉树**  
满二叉树节点数公式：`2^h - 1`

### 3.3 小例子
- h=2：最少 `2^2-1=3`  
- h=3：最少 `2^3-1=7`

> 一句话：**黑高=黑台阶数；要最少就只摆黑台阶并“层层铺满”→ 满二叉树 → 2^h-1。**

---

## 4.（拓展）根黑高为 h，内部结点最多多少？
最满的情况：每一层黑结点下面都“铺一层红结点”，形成约 **2h 层** 的满树形态：
\[
n_{\max}=2^{2h}-1
\]

---

## 5. 红黑树插入：核心套路（看叔叔脸色）
### 5.1 插入总流程
1) 先按 BST 查找位置插入  
2) 新结点：
   - 如果是根：**染黑**  
   - 如果非根：默认**染红**（减少黑结点变化）
3) 若违反性质（常见：出现“红红相邻”），开始调整  
4) **关键：看“叔叔（父结点的兄弟）”的颜色**

---

## 6. 插入调整两大分支
> 
> **“看叔节点：叔红就叔父爷变色；叔黑就看4种形态旋转+换色；变完之后爷当儿，儿当爷（位置变化）。”**

### 6.1 情况 A：叔叔是红色（红叔）
处理：**染色 + 向上继续**
- 父、叔：染黑  
- 爷：染红  
- 然后把“爷”当成新的当前结点，继续向上检查  
- 若爷变成根：根必须最终染黑

**记忆**：`红叔 → 叔父爷染色，爷变新结点（继续往上）`

---

### 6.2 情况 B：叔叔是黑色 / NULL（黑叔）
处理：**旋转 + 染色（一次到位）**  
根据“新结点-父-爷”的相对形态分四类：LL / RR / LR / RL

#### (1) LL 型（左左）
- 操作：对“爷”**右旋**
- 结果：**父换爷**（父上位）
- 染色：父染黑，爷染红（或“父爷互换颜色”）

#### (2) RR 型（右右）
- 操作：对“爷”**左旋**
- 结果：**父换爷**
- 染色：父黑，爷红（父爷互换色）

#### (3) LR 型（左右）
> 你纸上记的：`LR → LL →（再做LL那套）`
- 第一步：对“父”**左旋**（把 LR 变成 LL）
- 第二步：对“爷”**右旋**
- 结果：**儿换爷**（“儿子”上位成子树根）
- 染色：新子树根染黑，原爷染红（本质也是“换色”）

#### (4) RL 型（右左）
> 你纸上记的：`RL → RR →（再做RR那套）`
- 第一步：对“父”**右旋**（把 RL 变成 RR）
- 第二步：对“爷”**左旋**
- 结果：**儿换爷**
- 染色：新子树根黑，原爷红

**速记**：  
- **LL：右旋**；**RR：左旋**  
- **LR：先左后右**（先把弯拧直）  
- **RL：先右后左**（先把弯拧直）

---

## 7. BST 基础补充：前驱 / 后继
### 7.1 前驱（predecessor）
左孩子右底

### 7.2 后继（successor）

有孩子左底

---

## 8.最小不平衡子树（AVL 常考点）
当插入导致失衡时：从插入点往上找，遇到的**第一个失衡结点**为根的子树  
= **最小不平衡子树**（对它做 LL/RR/LR/RL 调整）