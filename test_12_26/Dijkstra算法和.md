# Dijkstra算法和

## 引言

首先我会想到什么是迪杰斯特拉？他在操作系统上的虚拟存储技术和进程同步和死锁和408数据小题和大题中都特别的重要！！！

Dijkstra 算法的设计是基于求解带权有向 / 无向图中单源最短路径的场景，且所有边的权重均为非负值。

![image-20251226202648052](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251226202648052.png)

这里我学完我的理解是他无非就是用了3个数组一个是为了找到最短路径而设置的 先顶一个源点，然后判断与它的相邻最短长度然后记录它对应的前驱节点，然后根据这连哥哥一组后他们的最短路径还有前驱一个一个记录最终形成一条最短路径，但是他不能针对负权值的带权图  

# 📝 Dijkstra 算法系统复习笔记模板

## 1. 算法背景与核心地位 (Context & Importance)

> **复习提示**：这里主要解决“它是什么”以及“为什么重要”的问题，特别是要区分 Dijkstra **本人**在 OS 中的贡献与**该算法**在 DS 中的应用。

- **发明者**：Edsger W. Dijkstra。
- **适用场景**：
  - 带权图（Weighted Graph）。
  - **有向** 或 **无向** 均可。
  - **关键限制**：边权 **必须为非负**（Weight≥0）。
- **考研 408 考点**：
  - **数据结构**：图的应用、单源最短路径。
  - **操作系统联想**：Dijkstra 提出的 PV 原语（信号量）和银行家算法（死锁避免）是 OS 重点，但本算法特指“最短路径”。
  - **计算机网络**：OSPF 协议（链路状态路由算法）底层就是 Dijkstra。

## 2. 核心思想：贪心策略 (The Greedy Strategy)

> **一句话总结**：**“步步为营，永远只选当前已知的最近邻居，并借此跳板去更新更远的地方。”**

- **本质**：基于 **广度优先搜索 (BFS)** 的改进。
- **贪心逻辑**：每一轮都从未被访问的节点中，选出距离源点 **最近** 的那个点，把它标记为“已确定（Final）”，然后以它为中心去“松弛”（Relax）周围的边。
- **为什么不能有负权边？**：因为贪心策略假设“当前选出的最短路径就是最终的最短路径”，如果有负权边，未来可能会出现“绕远路反而距离更短”的情况，贪心假设就会失效。

## 3. 核心数据结构：三个辅助数组

1. **`final[]` (或 `visited[]`)**：
   - **含义**：标记各顶点是否已经找到最短路径。
   - **初值**：源点为 `True`，其余为 `False`。
   - **作用**：将顶点分为两组：{已确定最短路径的集合 S} 和 {未确定的集合 V-S}。
2. **`dist[]`**：
   - **含义**：记录从源点到各个顶点的**当前**最短路径长度。
   - **初值**：源点为 0，与源点直接相连的为边权，不相连的为 ∞。
   - **变化**：随着算法进行，数值会不断变小（松弛操作）。
3. **`path[]` (或 `pre[]`)**：
   - **含义**：记录路径上的**前驱节点**（Predecessor）。
   - **作用**：用于最后回溯打印出完整路径（如：D←C←A）。

## 4. 算法流程与手算推演 

> **408 大题重点**：一定要熟练掌握表格法手算。
>
> ![Image of Dijkstra algorithm flowchart](https://encrypted-tbn0.gstatic.com/licensed-image?q=tbn:ANd9GcSyl5zMjXhsoRji0xia0RE-UZSMb4bL2qtRgBNKY3cIuZkTZqp48PD5zWlU9_QtESVUnPqbs5RO1XkT46ZzcgVptP-r2UY5wi_aJgh2Mw8ONd_D-R0)
>
> Shutterstock

- **初始化**：
  - 集合 S 初始化为 {源点}。
  - 更新 `dist[]` 和 `path[]`（仅看源点的邻居）。
- **循环操作**（共 n−1 轮）：
  1. **选最小 (Select)**：从 **未在 S 中** 的顶点中，选出 `dist` 值最小的顶点 u。
  2. **加入 S (Add)**：将 u 加入集合 S（`final[u] = True`）。
  3. **松弛 (Relax)**：检查 u 的所有邻居 v。
     - 若 `dist[u] + weight(u, v) < dist[v]`：
     - 则更新 `dist[v] = dist[u] + weight(u, v)`。
     - 并更新前驱 `path[v] = u`。

## 5. 复杂度分析 (Complexity)

> 选择题常考点。

- **时间复杂度**：
  - **邻接矩阵 / 普通数组实现**：O(∣V∣2)。因为每次都要遍历所有节点找最小。
  - **邻接表 + 二叉堆（优先队列）优化**：O(∣E∣log∣V∣)。适合稀疏图。
- **空间复杂度**：O(∣V∣)，主要用于存储那三个数组。

## 6. 纵向对比与易混淆点 (Comparison)

> 这是一个高分笔记必须有的环节，帮你把知识串起来。

| 特性           | Dijkstra               | Prim 算法 (最小生成树) | Floyd 算法        | Bellman-Ford / SPFA |
| -------------- | ---------------------- | ---------------------- | ----------------- | ------------------- |
| **用途**       | 单源最短路径           | 最小生成树 (MST)       | 多源最短路径      | 单源 (可处理负权)   |
| **核心逻辑**   | 找离**源点**最近的点   | 找离**当前树**最近的点 | 动态规划 (中转点) | 甚至可检测负权环    |
| **数组含义**   | `dist`存离**源点**距离 | `dist`存离**集合**距离 | 二维矩阵          | 队列优化            |
| **时间复杂度** | O(V2)                  | O(V2)                  | O(V3)             | O(VE)               |

- **特别注意**：Dijkstra 和 Prim 的代码结构极其相似，区别仅在于更新 `dist` 时的判断逻辑不同（考研常设坑）。