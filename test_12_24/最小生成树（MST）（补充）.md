# 最小生成树（MST）

## 引言

最小生成树（Minimum Spanning Tree, **MST**）是图论中的基本概念之一。在一个带权连通无向图中，**MST**指的是能够包含图中所有顶点且总边权值之和最小的生成树[[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=]()

维基百科有说明：https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91

换言之，MST连通图中所有节点，用最少的边总权重构成了一棵树。由于是树结构，它不含任何环路，并且边数是顶点数减一（若有 $n$ 个顶点，则生成树有 $n-1$ 条边）[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=)。

*MST 应用背景：* MST在现实中有广泛应用，如**网络设计**（构建低成本的通信、电网或道路连接方案）等。例如，可以利用 MST 策略规划城市道路以使总建设成本最低[blog.csdn.net](https://blog.csdn.net/m0_51725837/article/details/133357484#:~:text=最小生成树和最短路径都是图的应用 1)。MST 问题的求解也为算法设计提供了经典范例，常用贪心策略高效求解（Prim 算法、Kruskal 算法等）。

## 408考点要求概览

考试大纲要求考生理解并掌握最小生成树的定义、性质和经典算法实现。在408考试中，MST相关的常见考查方向包括：

- **Prim 与 Kruskal 算法步骤及应用** – 要能手工模拟算法过程，从给定图中正确选出 MST 的边序列（常见大题）**（408 高频考点）**。通常会指定用 Prim 算法从某起始顶点开始选边，或用 Kruskal 算法依次选边，要求写出每步选择的边。【此外要了解两种算法的时间复杂度及使用场景对比。】
- **MST 概念与性质判断** – 例如给出理论问答：判定最小生成树是否唯一及唯一的条件**（408 高频考点）**，或图中某特殊边是否一定属于 MST。典型真题：**“什么条件下带权连通图的 MST 是唯一的？”**（答案是：任意环路中各边权值均不相等，即所有边权各不相同时，MST 唯一[bbs.huaweicloud.com](https://bbs.huaweicloud.com/blogs/383937#:~:text=,当带权连通图的任意一个环中所包含的边的权值均不相同时，其 MST 是唯一的。)）。
- **相关概念区分** – 理解 **MST** 与 **最短路径树** 等概念的区别 **（408 高频考点）**，避免混淆。这类内容有时以选择题或判断题形式出现，例如区别 MST 与单源最短路径树的性质。
- **MST 性质及原理** – 掌握割性质、环性质等关键理论（虽是算法证明基础，偶尔也会以判断题形式考察理解）。例如判断给定断言：“环中最大权值边不可能在 MST 中” 是否正确。
- **综合与易错点** – 有些题会综合考查图论算法的比较，如让考生判断某种情况下 MST 算法与最短路径算法结果的关系，或者给出错误的 MST 构造步骤要求找错误之处等。

*提示：* 408 考试侧重基础知识和经典方法，对代码实现细节要求不多，但理解算法思想和能够手算过程是必须的。下面我们将按照考纲要求整理 MST 的定义性质、核心算法和性质定理，并突出**408 高频考点**供重点复习。

## 最小生成树的基本定义和特性

- **生成树定义：** 对于一个连通无向图，其**生成树**是包含图中全部 $n$ 个顶点的一个极小连通子图，具有无环性和连通性，且正好有 $n-1$ 条边[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=)。如果原图不连通，则针对每个连通分量各有一棵生成树（称为生成森林）。
- **最小生成树定义：** 在所有可能的生成树中，总边权值之和最小的那一棵称为图的**最小生成树（MST）**MST 仍然包含全部顶点且有 $n-1$ 条边，只是总权重最小。
- **唯一性:** 最小生成树不一定唯一；当图中存在若干边权相同时，可能有多棵不同的生成树都达到最小权重。但**若图中所有边权值各不相同，则 MST 是唯一的**[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=不难看出，最小生成树具有如下性质：)[blog.csdn.net](https://blog.csdn.net/m0_53605808/article/details/147014834#:~:text=,条边。)**（408 高频考点）**。反之如果存在权值相等的不同边，可能出现多种选择导致不同的 MST，但**它们的总权重都是相同的最小值**[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=1,最小生成树的边数为顶点数减1。)。
- **与最短路径树的区别:** MST 注重**全局权重最小**，保证遍历所有顶点的总代价最低，但**不保证任意两点之间的路径最短**[blog.csdn.net](https://blog.csdn.net/m0_51725837/article/details/133357484#:~:text=3.最小生成树和最短路径的区别和关系： 最小生成树能够保证首先是树（对于n个顶点的图只有n,1条边的树，最短路径是从一个点到另一个点的最短路径。)。而**最短路径树**（如单源最短路径算法得到的树）是以某个源点为根，使该源点到其他各顶点的路径长度分别最小的树，它不一定包含所有边或形成全局最优的 spanning tree。例如，MST 关注覆盖整个图的总成本最小，具有 $n-1$ 条边；最短路径树关注从起点到各终点距离最小，往往不是全覆盖的（只关注可达节点）且路径条数不固定[blog.csdn.net](https://blog.csdn.net/m0_51725837/article/details/133357484#:~:text=3.最小生成树和最短路径的区别和关系： 最小生成树能够保证首先是树（对于n个顶点的图只有n,1条边的树，最短路径是从一个点到另一个点的最短路径。)。**简而言之：**MST求的是“连接所有点的总代价最小”的树，而最短路径求的是“两点之间代价最小”的路径[blog.csdn.net](https://blog.csdn.net/m0_51725837/article/details/133357484#:~:text=3.最小生成树和最短路径的区别和关系： 最小生成树能够保证首先是树（对于n个顶点的图只有n)。两者所满足的性质和应用场景不同，应避免混淆 **（408 高频考点）**。

*(注：此处可配图说明 MST vs 最短路径树的结构区别)*

## 两大算法：Prim 算法 与 Kruskal 算法

最小生成树问题经典地可以用**贪心算法**求解，其中以 **Prim** 算法和 **Kruskal** 算法最为著名，也是考研408重点要求掌握的内容。下面分别介绍这两种算法的基本思想、步骤流程、适用场景、时间复杂度及常见考点提示。

### Prim 算法

**基本思想：** Prim 算法以**逐步扩展**的贪心策略构造 MST。它从图中任意选取一个起始顶点（考试中通常会指定，例如从顶点A开始），将其加入生成树，然后重复执行：每次从当前生成树出发，选择一条**权值最小的边**连接一个尚未在树中的顶点，并将该顶点和边加入生成树。如此迭代，直到所有顶点都并入生成树为止[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=Prim 算法构造最小生成树的过程如图 6,1条边。)。由于每一步都选取当前最优（最近）的边，Prim 算法确保最终得到 MST。

**算法步骤（贪心扩展）：** 可以按以下步骤模拟 Prim 算法来求 MST：

1. **初始化：** 任取起始顶点加入生成树集合 $U$（已选顶点集）。初始时 $U={ \text{start} }$，树边集合 $T=\emptyset$。
2. **选最小边：** 在所有**一端在集合 $U$、另一端在 $V-U$**（未加入集合的顶点）之间的跨边中，找到权值最小的边 $(u, v)$，其中 $u \in U$, $v \in V-U$。
3. **加入生成树：** 将选中的顶点 $v$ 以及边 $(u,v)$ 加入生成树：即 $U = U \cup {v}$， $T = T \cup {(u,v)}$。
4. **重复迭代：** 回到第2步，直到 $U$ 包含了图的所有顶点（此时边数为 $n-1$，算法结束）。得到的边集合 $T$ 即为最小生成树的边集。

上述过程中，每次选边的依据相当于选择当前**跨越“已建树”和“未建树”间割**的最小权边（这正是 MST 割性质的应用，保证选择安全）[blog.csdn.net](https://blog.csdn.net/m0_53605808/article/details/147014834#:~:text=,Prim 算法）正确性的理论基础。)。Prim 算法本质是不断扩张树的**贪心**策略，直到包含所有顶点。

**示例:** 设下面的加权图以顶点A开始执行 Prim 算法：

- 初始 $U={A}$。
- 第1步：从 A 出发可选的最小边是 $(A,C)$，加入 C；
- 第2步：此时 $U={A,C}$，跨 $U$ 和 $V-U$ 的最小边是 $(C,B)$，加入 B；
- 第3步：$U={A,C,B}$，最小跨边是 $(B,D)$，加入 D；
- ... 依次直到所有顶点加入。最终选边集合构成 MST。

**时间复杂度：** 若使用邻接矩阵和简单选择实现，Prim 算法每次选边要扫一遍候选边，整体复杂度 **$O(n^2)$**（其中 $n=|V|$）[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=Image)。这种实现不依赖边数，适合**稠密图**情况（边多）[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=Prim 算法的时间复杂度为 O(V)。如果使用**优先队列**（最小堆）和邻接表优化，每次选最小边降为对数时间，则总体复杂度可达 **$O(E + V\log V)$**[zh.wikipedia.org](https://zh.wikipedia.org/zh-hans/最小生成树#:~:text=普里姆算法的每一步都会为一棵生长中的树添加一条边，该树最开始只有一个顶点，然后会添加Image%3A {\displaystyle V)[blog.csdn.net](https://blog.csdn.net/m0_53605808/article/details/147014834#:~:text=)（其中 $E$ 是边数）。不过在考研复习中，一般按照 $O(n^2)$ 理解即可。**（408 高频考点：\**需了解 Prim 的复杂度随实现不同而异，以及其在稠密图情况下的优势\**）**。

**适用场景：** 因其 $O(n^2)$ 实现对边数不敏感，Prim 算法**更适合边稠密的图**（当 $E$ 边接近 $n^2$ 量级时）[blog.csdn.net](https://blog.csdn.net/m0_51725837/article/details/133357484#:~:text=Image%3A 在这里插入图片描述 prim和kruskal都是贪心算法,eloge)，krus kal是先把边的权值排序一次再进行选择。)。在稀疏图上若用简单实现可能有点浪费，不过使用堆优化后对任意图都高效。Prim 算法另一个优点是可以在扩展过程中形成**连贯的树结构**，可以在图动态生成时使用。

**常考点提示：**

- Prim 算法属于**贪心算法**范畴，每步选择当前最优解（最小边）[blog.csdn.net](https://blog.csdn.net/m0_51725837/article/details/133357484#:~:text=Image%3A 在这里插入图片描述 prim和kruskal都是贪心算法,eloge)，krus kal是先把边的权值排序一次再进行选择。)。考题可能会问Prim算法的算法类型或策略。
- Prim 算法在实现时需要标记哪些顶点已加入树，以及及时更新候选边的最小权值，这是手算容易出错之处。
- **易混淆**: Prim 和 Dijkstra 算法过程相似（都逐步扩展集合）但用途不同。Prim 求全局最小生成树；Dijkstra 求单源最短路径树。考试中可能通过权重设计使两者过程类似来考查概念辨析，要明确区分这两类问题。
- **边起始顶点选择**: Prim 算法可从任意顶点开始，最终 MST 总权重不变。但演示过程中选不同起点可能产生不同的构造顺序（特别在存在权值相等边时）。考试若明确指定起点，则按要求从该点开始构造。

### Kruskal 算法

**基本思想：** Kruskal 算法采取的是**从边的角度**进行贪心选择。它将图中所有边按权值从小到大排序，依次尝试选取最小的边，如果这条边与已选边集合一起**不形成环路**，则接受它；若加入该边会产生环，则跳过它。如此持续直到选出的边数达到 $n-1$，生成了一棵覆盖所有顶点的树[zh.wikipedia.org](https://zh.wikipedia.org/zh-hans/最小生成树#:~:text=主条目：克鲁斯克尔演算法)。

**算法步骤（贪心选边）：** Kruskal 算法可分为以下阶段：

1. **初始化：** 将图中所有边按照权重从小到大排序。初始化生成森林 $F$，开始时每个顶点自成一个独立的连通分量（尚未连通）。
2. **选边构造：** 从已排序的边列表中，按权值从小到大遍历每条边 $(u,v)$：
   - 如果当前边连接的两个顶点 $u$ 和 $v$属于**不同的连通分量**（即当前还不连通，加入此边不会成环），则选取此边，将其加入生成树集合 $T$，并合并这两个顶点的分量（在实现上可用并查集 **Union-Find** 来高效判断连通性并合并）[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=与 Prim算法从顶点开始扩展最小生成树不同，Kruskal算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。)。
   - 如果当前边连接的顶点已在同一连通分量中（已经通过之前选的边连通），则跳过此边，以避免环路[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=Kruskal 算法构造最小生成树的过程如图6.16 所示。初始时为只有n个顶点而无边的非连通图T%3D,T%2C否则舍弃此边而选择下一条权值最小的边。以此类推，直至T中所有顶点都在一个连通分量上。)。
3. **迭代结束：** 重复第2步，直到已选边数达到 $n-1$ 或边列表耗尽。此时若图是连通的，则 $T$ 中正好有 $n-1$ 条边并构成最小生成树；如果图非连通，则 Kruskal 会只构造出每个连通分量的最小生成树（生成森林）。

在构造过程中，Kruskal 每次选边相当于**挑选当前图中可安全添加的最小权边**，这利用了 MST 的**环性质**：若当前边是环中最重边则不选，否则选用之即安全[blog.csdn.net](https://blog.csdn.net/m0_53605808/article/details/147014834#:~:text=,Prim 算法）正确性的理论基础。)[blog.csdn.net](https://blog.csdn.net/m0_53605808/article/details/147014834#:~:text=)。这样能保证选择的每条边都在某棵 MST 中是合理的，最终得到全局最优解。

**时间复杂度：** Kruskal 算法主要开销在于**边排序**和**并查集操作**。排序需要 $O(E\log E)$ 时间；之后遍历边时，每条边执行并查集查找/合并近似为 $O(\alpha(n))$（很小，可视作常数），因此总复杂度约为 **$O(E \log E)$**[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=在 Kruskal算法中，最坏情况需要对因条边各扫描一次。通常采用堆)。相对而言，它**不依赖顶点数线性项**，当顶点很多而边相对较少时效率更高[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=在 Kruskal算法中，最坏情况需要对因条边各扫描一次。通常采用堆)。**（408 高频考点：\**需了解 Kruskal 排序主导的 $O(E\log E)$ 复杂度，以及它在稀疏图情况下的优势\**）**。

**适用场景：** Kruskal 算法适用于**边稀疏但顶点较多**的图[blog.csdn.net](https://blog.csdn.net/qq_55882840/article/details/142681142#:~:text=Image)。在这种情况下 $E \log E$ 相对低于 $V^2$。由于一步选一条边，Kruskal 更易于并行化或拓展找第$k$最小生成树等。此外，Kruskal 常用于需要灵活处理边集的情境，比如动态增加边的场景。

**常考点提示：**

- Kruskal 亦是**贪心算法**的典型代表，每次择当前剩余边中权值最小且“安全”的边加入[blog.csdn.net](https://blog.csdn.net/m0_51725837/article/details/133357484#:~:text=Image%3A 在这里插入图片描述 prim和kruskal都是贪心算法,eloge)，krus kal是先把边的权值排序一次再进行选择。)。考题可能问及该算法的基本思想或贪心选择依据。
- **并查集（Union-Find）**在 Kruskal 实现中至关重要，用于快速判断两个顶点是否已连通及合并集合。这往往是算法实现层面的考察点，需理解其作用。考试中可能不会让写并查集代码，但会默认考生了解其用途。
- **易错点：** 手工执行 Kruskal 时，易漏掉检查环路这一步骤（必须确保选边不会与已选边形成环）。建议在选每条边时明确记录当前连通分量或已选边组成的森林结构，以避免错误加入导致环路。
- Kruskal 算法构造 MST 过程中，如果原图非连通，将无法得到包含所有顶点的单棵树。这种情况下 MST 概念不适用，只能得到各连通分量的生成树。考试通常假定输入图是连通的，但要理解非连通时算法行为（生成森林）以防万一概念题出现。

## 最小生成树的关键性质：割性质与环性质

MST 能够成立的贪心选择，依赖于下面两个重要性质（定理），它们既是算法设计的理论基础，也常用于判断某条边是否在 MST 中的推理。

- **割性质（Cut Property）：\**对于任意将图的顶点集划分为两部分的一个\**割**，考察跨越这个割的所有边（称为**割边**）。其中如果存在一条边的权值严格小于其它所有割边，则这条**最小权割边**一定在某棵最小生成树中[zh.wikipedia.org](https://zh.wikipedia.org/zh-hans/最小生成树#:~:text=S%3D\left\{A%2CB%2CD%2CE\right\}} zh.wikipedia.org ，则Image%3A {\displaystyle V,displaystyle T}的一部分。)[blog.csdn.net](https://blog.csdn.net/m0_53605808/article/details/147014834#:~:text=,Prim 算法）正确性的理论基础。)。换言之，连接两个分割部分的最小代价边是构造 MST 的“安全边”。
   *举例:* 如下图把顶点集合划分成两部分 $S$ 和 $V-S$，设跨割的边中权值最小的是 $(X,Y)$，那么无论最小生成树如何构造，边 $(X,Y)$ 都必然会被包含，否则如果不用这条边而用其他更大的边连接两部分，将导致总权重不最小，与 MST 定义矛盾。这个性质解释了为何 Prim 算法每次选最小跨边是合法的：每一步选的都是当前割（已选顶点集 vs 未选顶点集）的最小边，保证最优性。
- **环性质（Cycle Property）：\**在连通图的任一\**环**路中，若存在一条边的权值比该环中其他边都大，则这条**最大权边**不可能在最小生成树中[zh.wikipedia.org](https://zh.wikipedia.org/zh-hans/最小生成树#:~:text=)[blog.csdn.net](https://blog.csdn.net/m0_53605808/article/details/147014834#:~:text=)。原因是：生成树不含环，若环中最重边在候选集合中，我们完全可以舍弃它而选择环上其他更便宜的边来连通同样的顶点，从而降低总权值。
   *举例:* 若图中有一个环路包含边权值分别为2、5、7，其中最大的边权为7，那么这条权重为7的边在 MST 中一定不会出现——我们总会优先选择权值2和5的边即可连通该环的所有顶点，舍弃7不会影响连通性且降低总权重。

上述两个性质揭示了 MST 的贪心选择原则：割的最小边必选、环的最大边必弃。这也提供了一些快速判断 MST 边的技巧，例如：**图中权值最小的一条边必然属于 MST**（可看作割性质的特例）; 反之**权值最大的边如果参与形成环，一定不是 MST 所需**。在考试中，如果出现判断题考查某条边是否在 MST 中，可考虑运用这些性质分析其在环或割中的相对权值来决定。

## 易错点与典型题型总结

在学习和应用 MST 知识时，考生容易出现一些误区和错误，以下列出常见的易错点，并总结典型题型以帮助备考。

- **概念混淆：\**务必区分 MST 与最短路径树的差异\**（408 高频考点）**。有些考生会误以为 MST 也保证两点之间的最短距离，这是错误的[blog.csdn.net](https://blog.csdn.net/m0_51725837/article/details/133357484#:~:text=3.最小生成树和最短路径的区别和关系： 最小生成树能够保证首先是树（对于n个顶点的图只有n,1条边的树，最短路径是从一个点到另一个点的最短路径。)。MST 追求的是全局总权最小，而最短路径树针对单一源点求局部最优路径。历年选择题常考此概念辨析，如判断“最小生成树一定包含图中任意两点之间的最短路径”这类断言（该断言是**错**的）。
- **算法步骤错误：\**手算 Prim 或 Kruskal 算法时常犯错误包括：Prim 算法过程中未正确更新候选边权值，导致选错下一条边；Kruskal 算法漏掉了跳过成环边的判断，错误地加入了形成环路的边。建议在演练时严格按照算法步骤来，每一步都检查\**候选边集合**或**连通分量状态**。
- **环路与连通判断:** 生成树最重要的特征是**无环**且**连通**。易错点在于一些选边策略忽视了环的产生或连通性的维持。例如，有的同学在 Kruskal 选边时，只关注当前边权最小而忘记检验它是否连接了已连通的顶点，最终选出多于 $n-1$ 条边产生环；或在 Prim 算法中可能一时大意选了一条连接已在树中的两个顶点的边（应予以避免）。克服办法是牢记：“MST 总有 $n-1$ 条边，没有环，新增一条边前后连通分量数减一”。
- **MST 唯一性判断:** 关于 MST 是否唯一是考试爱考的小题**（408 高频考点）**。常见问法如前述：“什么条件下 MST 唯一？”。解答基于权值比较：**如果图中所有环内不存在等权边，即边权全部互异，则 MST 唯一**[bbs.huaweicloud.com](https://bbs.huaweicloud.com/blogs/383937#:~:text=,当带权连通图的任意一个环中所包含的边的权值均不相同时，其 MST 是唯一的。)。反之只要存在一个环有两条或以上边权相同且为最小，那么选择不同边可形成不同的 MST。答题时要明确条件是“各边权值皆不相等”。
- **特殊边分析:** 考试可能以判断题形式考知识点，比如：“权值最小的边一定在某最小生成树中”是真命题（若只有一条全图最小边，它必定安全，可列入 MST）[zh.wikipedia.org](https://zh.wikipedia.org/zh-hans/最小生成树#:~:text=如果图的具有最小权值的边只有一条，那么这条边包含在任意一个最小生成树中。)；“权值最大的边一定不在 MST 中”不一定全对，但若那条最大边参与形成某个环，则必不在 MST。这类题结合**割性质**和**环性质**很容易分析，复习时应对这些理论结论有所记忆。
- **典型题型1：手动画图构造 MST** – 给出一个小型加权图，要求考生用 Prim 或 Kruskal 算法找出其 MST，往往需要写出**边的选择顺序**或最终的边集合。例如“从顶点A开始执行 Prim 算法，按顺序给出选中的边”；或“使用 Kruskal 算法给出选边过程”。解题时建议画表格或示意图跟踪过程，确保不错选、漏选。
- **典型题型2：概念判定与填空** – 如前述关于唯一性的判断，或者填空题：“连通图有$n$个顶点，其最小生成树有__条边？”（答案$n-1$）；“Prim算法和Kruskal算法同属于__算法”（答案：贪心算法）等等。这类题考基础知识，需准确记忆MST性质和算法特点。
- **典型题型3: 综合应用题** – 新趋势可能出现结合MST的综合题，如“在某网络优化问题中加入约束求最小生成树变形”，或者考查当边权改变时 MST 如何更新（动态 MST 思想）。例如给定图的 MST，问如果增加/修改一条边权后怎样快速判断新的 MST。这部分属扩展内容，难度较高，通常非408必考，但了解一些思路有助于拓宽视野（可选学）。

总之，复习MST部分应注重**算法过程的熟练**和**性质定理的理解**。建议多做历年真题中的图论题目，特别是手算演练 Prim/Kruskal，确保考试时不慌不乱，避免上述易错点。

## 非必备拓展：算法实现代码示例

> 以下提供 Prim 和 Kruskal 算法的伪代码实现（Python 风格），作为理解算法流程的参考。考试中一般不要求写代码，此部分属于扩展阅读。

### Prim 算法伪代码

```
# Prim's Algorithm for MST (Adjacency matrix/list representation)
def prim_mst(graph):
    n = graph.num_vertices()
    selected = [False] * n            # MST包含的顶点标记
    selected[0] = True               # 从0号顶点开始（任意选择起点）
    mst_edges = []                   # 存储MST边的列表
    for _ in range(n - 1):           # 循环选出 n-1 条边
        min_weight = INF
        u, v = -1, -1
        # 遍历所有已选顶点与未选顶点之间的边，找到权重最小的边 (u,v)
        for i in range(n):
            if selected[i]:
                for j, w in graph.adj[i]:   # 邻接表：i的邻居j及权重w
                    if not selected[j] and w < min_weight:
                        min_weight = w
                        u, v = i, j
        selected[v] = True            # 将顶点v加入 MST 集合
        mst_edges.append((u, v, min_weight))
    return mst_edges  # 返回最小生成树的边集合
```

### Kruskal 算法伪代码

```
# Kruskal's Algorithm for MST
def kruskal_mst(graph):
    edges = graph.get_all_edges()            # 获取所有边列表 (u, v, weight)
    edges.sort(key=lambda e: e.weight)       # 按权值从小到大排序
    uf = UnionFind(graph.num_vertices())     # 初始化并查集
    mst_edges = []
    for e in edges:
        u, v, w = e.u, e.v, e.weight
        if uf.find(u) != uf.find(v):         # 若两个顶点不在同一连通分量
            uf.union(u, v)                   # 合并分量
            mst_edges.append((u, v, w))      # 选这条边
            if len(mst_edges) == graph.num_vertices() - 1:
                break
    return mst_edges
```

以上伪代码中使用了并查集结构 `UnionFind` 来支持连通性检查。实际实现时需定义 `find` 和 `union` 操作。通过阅读代码，可以再次体会Prim算法是**顶点驱动**逐渐扩展树，而Kruskal算法是**边驱动**全局选边。这两种算法各具特色，但最终产出的最小生成树权值必然相同，都是全局最优解。