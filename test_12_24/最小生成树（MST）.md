# 最小生成树（MST）

## 引言

最小生成树（Minimum Spanning Tree, **MST**）是图论中的基本概念之一。在一个**带权连通无向图**中，**MST**指的是能够包含图中所有顶点且总边权值之和最小的生成树

这个知识点在维基百科讲的很透彻：[](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)

到这我还是想分析下图的思维框架：

![](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251224173243449.png)

*MST 应用背景：* MST在现实中有广泛应用，如**网络设计**（构建低成本的通信、电网或道路连接方案）等。例如，可以利用 MST 策略规划城市道路以使总建设成本最低[blog.csdn.net](https://blog.csdn.net/m0_51725837/article/details/133357484#:~:text=最小生成树和最短路径都是图的应用 1)。MST 问题的求解也为算法设计提供了经典范例，常用贪心策略高效求解（Prim 算法、Kruskal 算法等）。

必须掌握的知识点：

- 生成树 / MST 定义；生成树边数一定是 **n-1**
- Prim 与 Kruskal：思想、步骤、手推、复杂度、适用场景
- 非连通图：没有生成树，只有生成森林
- 易错点：Prim 的 lowCost 更新、Kruskal 的判环（并查集）
- MST 唯一性：所有边权互不相同 ⇒ MST 唯一（常见结论）

---

## 概念与性质

### 1. 生成树
- 定义：连通无向图的生成树是包含图中**所有顶点**的极小连通子图  
- 性质（记忆版）：
  - 若有 n 个顶点，则生成树有 **n-1 条边**
  - 生成树：**连通 + 无环**
  - 删任意一条树边 ⇒ 不连通；加任意一条边 ⇒ 一定成环
  
  <img src="C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251224211736137.png" alt="image-20251224211736137" style="zoom:67%;" />

### 2. 最小生成树（MST）
- 定义：在所有生成树中，**边权和最小**的那一棵
- 补充：
  - MST 可能不唯一（边权相等时容易出现多解）
  - 图不连通：只能得到**最小生成森林**

> 【易混淆】MST ≠ 最短路径树  
> MST 最小化“整棵树总边权”；最短路径树最小化“源点到各点的路径长度”。

---

## *Prim 算法*

### 思想（一句话）
从某个起点出发，维护已加入集合 S，每次选一条**连接 S 与外部**的最小权边，把新顶点并入。

### 手推流程
- 初始化：选起点加入 S  
- 重复 n-1 次：
  1) 在所有跨边（u∈S, v∉S）中选权值最小的一条  
  2) 加入该边与新顶点 v  
  3) 更新其它未加入顶点到集合 S 的最小代价（lowCost）

> ![image-20251224212606714](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251224212606714.png)

### 复杂度与适用场景
- 邻接矩阵实现：**O(|V|²)**  
- 适合：**稠密图**（边很多）

### 【拓展】一句话优化
- 若用最小堆 + 邻接表，可优化到约 **O(|E| log|V|)**（了解即可）



---

## Kruskal 算法

### 思想
先把边按权从小到大排序，依次尝试加入：**不会成环就加，会成环就跳过**，直到选满 n-1 条边。

### 手推流程（考试写法）
1) 将所有边按权值升序排序  
2) 从小到大扫描每条边 (u,v)：
   - 若 u 和 v 当前不连通 ⇒ 选这条边（合并两个连通分量）
   - 若 u 和 v 已连通 ⇒ 跳过（否则会形成环）
3) 选边数达到 n-1 时结束

> ![image-20251224212546817](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251224212546817.png)

### 复杂度与适用场景（【408必会】）
- 排序主导：**O(|E| log|E|)**  
- 适合：**稀疏图**（边相对少）

### 【拓展】并查集一句话
- 判环常用并查集：判断两端点是否在同一集合（find），不在则 union 合并

---

## Prim vs Kruskal 对比（【408必会】）

| 对比点         | Prim                        | Kruskal                |
| -------------- | :-------------------------- | ---------------------- |
| 选择方式       | 扩点/长树（跨集合选最小边） | 选边（全局从小到大试） |
| 判环方式       | 天然不会成环（只连外部点）  | 必须判环（并查集常用） |
| 复杂度（常用） | O(                          | V                      |
| 更适合         | 稠密图                      | 稀疏图                 |
| 手推关键       | lowCost / isJoin 更新       | 边排序 + 判环          |

## 

### 题型 1：手推 MST
- Prim：每轮找 lowCost 最小且未加入的顶点，并更新 lowCost
- Kruskal：边按权排序，逐条判断是否会成环

##### 知道算法就行可以CSDN找几个看看思路

[普利姆算法（prim）求最小生成树（MST)过程详解_普利姆算法构造最小生成树的过程-CSDN博客](https://blog.csdn.net/jiangguangchao/article/details/102696501)

### 题型 2：概念判断
- 生成树边数 = n-1
- 非连通图没有生成树（只有生成森林）
- MST 不一定唯一（边权相等时）

### 易错点清单（很重要）
- Prim：
  - 忘记更新 lowCost
  - 误选了“两个都在 S 内”的边（不应该）
- Kruskal：
  - 漏掉判环（导致选出环）
  - 边排序写错/漏边

---

## 复盘 Checklist（考前 3 分钟过一遍）
- [ ] 我能一句话说清：生成树 / MST / 生成森林
- [ ] 我记得：生成树边数必为 n-1
- [ ] 我会手推 Prim（lowCost 表）并写出选边顺序
- [ ] 我会手推 Kruskal（排序 + 判环）并写出选边顺序
- [ ] 我能对比两算法复杂度，并知道稠密/稀疏怎么选