# **BFS 遍历过程中 “动态记录”** 代码理解

### 第一步：初始化数组

先给 3 个数组赋初始值（假设顶点编号是 1~8）：

- `visited[] = [false, false, false, false, false, false, false, false]`（全未访问）
- `d[] = [∞, ∞, 0, ∞, ∞, ∞, ∞, ∞]`（只有起点 2 的长度为 0，其余都是 “无穷大”）
- `path[] = [-1, -1, -1, -1, -1, -1, -1, -1]`（-1 表示 “无前驱”，起点 2 也没有前驱）

### 第二步：BFS 遍历，逐个记录前驱顶点

BFS 是 “从起点出发，一层一层访问邻接顶点”，每访问一个新顶点，就给它的`path[]`赋值：

1. **处理起点 2**：

   标记`visited[2] = true`（已访问），然后看 2 的邻接顶点（比如 1、3、6）：

   - 顶点 1：没被访问过 → 记`path[1] = 2`（1 是从 2 找到的，所以 1 的前驱是 2），同时`d[1] = d[2]+1 = 1`，标记`visited[1]=true`；
   - 顶点 3：没被访问过 → 记`path[3] = 2`（3 的前驱是 2），`d[3] = 1`，`visited[3]=true`；
   - 顶点 6：没被访问过 → 记`path[6] = 2`（6 的前驱是 2），`d[6] = 1`，`visited[6]=true`。

2. **处理顶点 1**（从队列取出）：

   看 1 的邻接顶点（只有 2，已访问）→ 无新顶点，跳过。

3. **处理顶点 3**（从队列取出）：

   看 3 的邻接顶点（比如 4）：

   - 顶点 4：没被访问过 → 记`path[4] = 3`（4 是从 3 找到的，前驱是 3），`d[4] = 2`，`visited[4]=true`。

4. **处理顶点 6**（从队列取出）：

   看 6 的邻接顶点（比如 8）：

   - 顶点 8：没被访问过 → 记`path[8] = 6`（8 的前驱是 6），`d[8] = 2`，`visited[8]=true`。

（后续处理 4、8 等顶点逻辑一致，都是 “找到新顶点→记前驱为当前处理的顶点”）

![image-20251224214245976](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251224214245976.png)