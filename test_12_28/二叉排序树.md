# 二叉排序树

## 引言：

啥事二叉排序树啊？

![image-20251228130031726](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251228130031726.png)

一张图一目了然

```c
// 定义二叉排序树（Binary Search Tree, BST）节点的结构体
typedef struct BSTNode {
    int key;                // 节点存储的关键字（核心数据，通常为整数）
    struct BSTNode *lchild; // 指向左孩子节点的指针（左孩子key < 当前节点key）
    struct BSTNode *rchild; // 指向右孩子节点的指针（右孩子key > 当前节点key）
} BSTNode; // 给结构体起别名，后续可直接用BSTNode声明变量，无需写struct BSTNode
```

这是**C 语言中 “二叉排序树（BST）节点” 的结构体定义**，用来描述二叉排序树中单个节点的结构，分解来看：

1. **`typedef struct BSTNode`**
   - `struct BSTNode`：定义了一个名为`BSTNode`的结构体（`BST`是 “Binary Search Tree（二叉排序树）” 的缩写）。
   - `typedef`：给这个结构体起一个 “别名”，之后可以直接用`BSTNode`代替`struct BSTNode`来声明变量，简化代码。
2. **结构体内部成员**
   - `int key`：节点存储的**关键字（数据）**，比如要存在树里的数字。
   - `struct BSTNode *lchild, *rchild`：
     - `lchild`：指向**左孩子节点**的指针（二叉排序树中，左孩子的`key`通常比当前节点小）；
     - `rchild`：指向**右孩子节点**的指针（右孩子的`key`通常比当前节点大）。

简单说：这个代码是 “画了一个二叉排序树节点的‘模板’”，每个节点能存一个数字，还能通过指针连接它的左、右子节点，用来搭建整个二叉排序树。

# 二叉排序树的插入

```c
// 二叉排序树节点结构体（必须先定义，否则函数无法识别BSTNode）
typedef struct BSTNode {
    int key;                // 节点存储的关键字（数值）
    struct BSTNode *lchild;// 左孩子指针
    struct BSTNode *rchild;// 右孩子指针
} BSTNode, *BSTree;

// 二叉排序树的插入函数（递归实现）
// 参数：T - 指向当前子树根节点的指针（二级指针，用于修改原指针）；k - 要插入的关键字（数值）
// 返回值：1-插入成功，0-插入失败（关键字重复）


int BST_Insert(BSTNode **T, int k) {
    // 情况1：当前子树为空（递归到叶子节点的空孩子），创建新节点作为该位置的叶子节点
    if (*T == NULL) {
        // 为新节点分配内存
        *T = (BSTNode *)malloc(sizeof(BSTNode));
        // 初始化新节点：关键字为k，左右孩子为空（叶子节点）
        (*T)->key = k;
        (*T)->lchild = NULL;
        (*T)->rchild = NULL;
        return 1; // 插入成功
    }

    // 情况2：要插入的关键字k与当前节点的关键字重复，插入失败
    if (k == (*T)->key) {
        return 0;
    }

    // 情况3：k小于当前节点的关键字，递归插入到左子树
    if (k < (*T)->key) {
        return BST_Insert(&((*T)->lchild), k);
    }
    // 情况4：k大于当前节点的关键字，递归插入到右子树
    else {
        return BST_Insert(&((*T)->rchild), k);
    }
}
```

k 不是 “新节点”，而是要插入的关键字（数值） —— 也就是你说的 “节点上的数字”（比如 12、11、15 这些具体数值）。新节点是函数内部根据 k 这个数值创建的，k 只是节点要存储的核心数据。

T 是指向二叉排序树节点的指针（通常是二级指针 BSTNode **T，因为要修改指针的指向，比如空树时创建根节点），代表当前递归处理的子树的根节点：

- 初始调用时，T 指向整棵树的根节点；
- 递归过程中，T 会指向左 / 右子树的根节点；
- T->key 就是你说的 “节点上的数字”—— 当前节点存储的关键字数值。

## 如果是非递归插入呢

1. **空树处理**：如果根节点`*T`为 NULL，直接创建根节点（和递归版本一致）；
2. **遍历指针与父节点指针**：
   - `p`：用于遍历树的当前节点，从根开始移动；
   - `parent`：**核心指针**，始终记录`p`的上一个节点（父节点），因为当`p`走到 NULL 时，新节点要挂在`parent`的空孩子上；
3. **循环终止条件**：`p == NULL`（找到插入位置），此时`parent`就是新节点的父节点；
4. **新节点挂载**：
   - 若`k < parent->key`：新节点作为`parent`的左孩子；
   - 若`k > parent->key`：新节点作为`parent`的右孩子；
   - 这一步保证了 BST 的核心规则（左小右大）。

# 二叉排序树的删除

![image-20251228152127848](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251228152127848.png)

↓

![image-20251228152159789](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251228152159789.png)

### 第三种情况

![image-20251228154235399](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251228154235399.png)

一共三种情况这里 

![image-20251228152247896](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251228152247896.png)

![image-20251228154223125](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251228154223125.png)



# 查找效率

ASL = 总和 ÷ 节点数 = `21 ÷ 8 = 2.625`

用之前的例子再明确下：

比如左边的树：

- 第一层：查找长度 = 1，节点数 = 1 → 贡献是「1×1」
- 第二层：查找长度 = 2，节点数 = 2 → 贡献是「2×2」
- 第三层：查找长度 = 3，节点数 = 4 → 贡献是「3×4」
- 第四层：查找长度 = 4，节点数 = 1 → 贡献是「4×1」

把这些贡献加起来，才是 “总和”：`1×1 + 2×2 + 3×4 + 4×1 = 21`。

而 ASL 是 “总和 ÷ 总节点数”，这里总节点数是 8，所以`21÷8=2.625`。

简单说：

总和 = （每层查找长度 × 该层节点数）的累加

ASL = 总和 ÷ 总节点数

![image-20251228153508479](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251228153508479.png)

## 平衡二叉树

![image-20251228153704049](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251228153704049.png)

## 这里设计查找失败的asl

![image-20251228154042023](C:\Users\Rory\AppData\Roaming\Typora\typora-user-images\image-20251228154042023.png)

第一步：明确 “查找失败的 ASL” 的计算规则

查找失败的 ASL，是针对 **“不存在的关键字” 的查找过程 **—— 当查找一个树里没有的关键字时，会走到树的 “空指针位置”（图里的紫色方块），这些空位置就是 “查找失败的位置”。

计算逻辑是：

总和 = （每个失败位置的查找长度 × 该长度对应的失败位置数）的累加

ASL（失败） = 总和 ÷ 失败位置的总数

第二步：分析这棵树的 “失败位置” 和 “查找长度”

先看这棵树的结构 + 图里的紫色方块（失败位置）：

树的节点层级：

- 第 1 层：50（根）
- 第 2 层：26、66
- 第 3 层：21、30、60、70
- 第 4 层：68

**失败位置（紫色方块）共有 9 个**，每个位置的 “查找长度” 是 “从根到这个空位置，需要对比关键字的次数”（即经过的节点数）：

1. **查找长度 = 3 的失败位置**：共 7 个

   对应路径：根（50）→ 第 2 层节点 → 第 3 层节点，对比 3 次后走到空位置。

   比如：21 的左右空、30 的左右空、60 的左右空、70 的左空，共 7 个。

2. **查找长度 = 4 的失败位置**：共 2 个

   对应路径：根（50）→ 第 2 层 → 第 3 层 → 第 4 层（68），对比 4 次后走到空位置。

   比如：68 的左右空，共 2 个。

第三步：计算失败 ASL

总和 = （3 × 7） + （4 × 2） = 21 + 8 = 29

ASL（失败） = 总和 ÷ 失败位置总数 = 29 ÷ 9 ≈ 3.22（和图里的结果一致）

