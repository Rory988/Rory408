## 0）必备小工具

```c
static inline void swap(int *a, int *b){
    int t = *a; *a = *b; *b = t;
}
```

## 1）插入类（Insertion / Shell）

### 1.1 直接插入排序（会写）

```c
void InsertSort(int A[], int n){
    for(int i=1;i<n;i++){
        int key=A[i];
        int j=i-1;
        while(j>=0 && A[j]>key){
            A[j+1]=A[j];
            j--;
        }
        A[j+1]=key;
    }
}
```

### 1.2 折半插入排序（会写：二分找位置 + 后移）

```c
int lower_bound_pos(int A[], int l, int r, int key){ // 在[l,r]找第一个>=key的位置
    while(l<=r){
        int m=(l+r)/2;
        if(A[m]>=key) r=m-1;
        else l=m+1;
    }
    return l;
}
void BinaryInsertSort(int A[], int n){
    for(int i=1;i<n;i++){
        int key=A[i];
        int pos=lower_bound_pos(A,0,i-1,key);
        for(int j=i-1;j>=pos;j--) A[j+1]=A[j];
        A[pos]=key;
    }
}
```

 int pos=lower_bound_pos(A,0,i-1,key)————这行代码的核心是调用一个名为 `lower_bound_pos` 的自定义函数，在数组 `A` 的**指定有序区间**（下标从 `0` 到 `i-1`）中，查找**第一个大于或等于 `key` 值的元素的下标**，并将这个下标赋值给整型变量 `pos`。

### 1.3 希尔排序（会写：按 gap 做“分组插入”）

> 增量（gap）逐步减小的思路来自 PPT：按增量序列分组进行插入排序 8.2.3 希尔排序

```c
void ShellSort(int A[], int n){
    for(int gap=n/2; gap>0; gap/=2){
        for(int i=gap;i<n;i++){
            int key=A[i];
            int j=i-gap;
            while(j>=0 && A[j]>key){
                A[j+gap]=A[j];
                j-=gap;
            }
            A[j+gap]=key;
        }
    }
}
```