# 图算法：Dijkstra、Floyd与AOV/AOE网的深度解析

## 目录

- Dijkstra 算法（单源最短路径）
- Floyd 算法（多源最短路径）
- 拓扑排序（AOV 网）
- 关键路径算法（AOE 网）
- 参考资料

## Dijkstra 算法（单源最短路径）

> **我的理解：**Dijkstra 算法其实就是围绕三个数组反复迭代：先选定源点，找到与它距离最近的邻接点并记录其前驱；然后不断以新确定的节点为“跳板”松弛更新更远节点的距离，如此一步步扩展，最终得到从源点出发的最短路径树。**注意：**该算法不适用于含有负权边的图。

### 定义与适用场景

Dijkstra 算法是由计算机科学家 **Edsger W. Dijkstra** 提出的单源最短路径算法，用于求解从**单个源点**出发到图中**其他所有顶点**的最短路径。它适用于**带权有向或无向图**，但**要求边权非负**（不能有负权边）。在现实中，Dijkstra 算法被广泛应用于地图导航、网络路由（如 OSPF 协议）等场景。

- **基本思想：\**采用\**贪心策略**逐步扩展已知最短路径的范围，每一步都选择当前距离源点最近且尚未确定最短路的顶点加入结果集，然后利用该顶点**松弛**（relax）其邻边的距离。一句话总结即：“**步步为营，永远只选当前已知的最近邻居，并借此跳板去更新更远的地方。**”
- **关键特点：\**Dijkstra 实质上是对 BFS 的扩展，将 BFS 的均等一层一跳改为按照权重远近选择下一跳，因此能处理加权图的最短路问题。但由于其贪心假设“当前选出的路径即全局最优”，一旦存在\**负权边**这种假设就会被破坏，算法将无法正确工作（如果需要处理负权边，应使用 Bellman-Ford 或 SPFA 等算法）。
- **典型考点：\**属于考研408数据结构科目“图的应用”部分，重点考查\**单源最短路径**的原理与手算过程。考题常要求考生给出执行过程（例如画出迭代表格）或最终结果距离。由于 Dijkstra 与最小生成树的 Prim 算法在实现结构上非常相似，考试中也常以此设计陷阱，要求识别二者的差异（如松弛条件不同）。

（此处可插图示意 Dijkstra 算法在加权有向图上的逐步扩展过程，例如每轮选取最近顶点并更新周围距离的流程图）

### 核心数据结构

为了高效实现上述贪心过程，算法维护三个辅助数组：

- **`dist[]`：**记录源点到各顶点的当前最短距离估计值。初始时，源点 `dist[source]=0`，源点的直接邻接点设为对应边权，其他不相连点为 $\infty$。算法运行过程中，`dist[]`中的值只会越来越小，不断被松弛操作更新。
- **`final[]`（或称 `visited[]`）：**记录每个顶点是否已确定最终最短距离。初始时只有源点标记为已确定 (`True`)，其余顶点为未确定 (`False`)。该数组将顶点集划分为两部分：已确定最短路的集合 $S$ 和未确定集合 $V - S$。每一轮选择操作都从 $V-S$ 中选出距离最小者加入 $S$。
- **`path[]`（或 `pre[]`）：**记录最短路径树中每个顶点的前驱结点。当更短路径被发现时，相应顶点的前驱会被更新，用于算法结束后回溯还原完整路径。例如，若最终 `path[B] = A`，表示最短路径中 B 的前一个顶点是 A。通过反复追溯 `path[]` 可还原源点到任一顶点的路径。

### 算法步骤（伪代码实现）

下面给出 Dijkstra 算法的简洁伪代码实现：

```
// 初始化
for (v 从1到n顶点):
    dist[v] = INF;
    prev[v] = -1;            // 前驱初始化为-1表示无
dist[source] = 0;

for (i 从1到n): 
    final[i] = false;
final[source] = true;        // 源点加入集合 S

// 主循环，每次确定一个顶点的最短距离
for (round 从1到 n-1):  
    // 1. 从未确定集合中选择 dist 最小的顶点 u
    u = 未确定顶点中具有最小 dist 值者;
    final[u] = true;         // 将顶点 u 加入 S

    // 2. 松弛: 用 u 更新所有邻接顶点 v 的距离
    for (每个 u 的邻接顶点 v):
        if (!final[v] && dist[u] + w(u,v) < dist[v]) {
            dist[v] = dist[u] + w(u,v);
            prev[v] = u;
        }
```

**关键公式：**在松弛操作中，如果发现经过当前顶点 $u$ 到邻居 $v$ 的路径更短，则更新目标顶点的距离：
 $**若**\ dist[u] + w(u,v) < dist[v]\ **则**\ dist[v] = dist[u] + w(u,v)，并设置 `prev[v] = u`:contentReference[oaicite:11]{index=11}.$

算法在更新过程中保持 `dist[]` 为源点到各顶点的**最短路径长度的上界**。当算法结束时，`dist[]` 中存储的即为源点到每个顶点的最短路径长度，而 `prev[]` 则隐含了最短路径树的结构。

### 算法复杂度与优化

- **时间复杂度：\**使用朴素实现（邻接矩阵或简单数组找最小值）时，每次选最小操作需要扫描所有顶点，整体复杂度 $O(n^2)$。若使用\**优先队列**优化（适用于邻接表存储稀疏图），可将选最小和松弛操作合并，整体复杂度降为 $O(m \log n)$（其中 $m$ 为边数）。
- **空间复杂度：**主要为三个辅助数组，占用 $O(n)$ 空间。通常还需要存储图的邻接矩阵或邻接表。
- **可优化与变体：\**针对\**稀疏图**，使用二叉堆、斐波那契堆优化选择最小顶点的步骤是常见手段。对于存在**负权边**的情况，Dijkstra 不可用，需要采用 Bellman-Ford 算法或 SPFA 算法等；对于无权图，则可退化为简单的 BFS。

### 典型考点摘要

- **手算过程：\**408 考试常以大题要求考生\**手工模拟 Dijkstra 算法**，给出每轮选取的顶点及 `dist[]` 数组更新表格。务必熟练掌握算法迭代步骤，确保正确选取最短临近顶点并完成松弛更新。
- **与 Prim 算法区别：**两者代码结构极其相似，考试可能通过给伪代码让考生判断是最短路还是最小生成树算法。关键区别在于：**Dijkstra 的 `dist[]` 含义是“源点到该顶点的距离”**，而 Prim 算法中 `dist[]` 表示“当前生成树到该顶点的距离”；以及松弛时 Dijkstra 比较的是新路径是否更短，而 Prim 比较的是是否有更小权重边可连接。牢记这一点可避免掉入考题陷阱。

## Floyd 算法（多源最短路径）

> **我的理解：\**Floyd-Warshall 算法本质上是\**动态规划**思想在图论中的应用，它通过让每个顶点依次充当“中转站”，不断松弛更新任意两点之间的路径长度，最终求得所有顶点对之间的最短路径。

### 算法定义与特点

**Floyd 算法**（又称 Floyd-Warshall 算法）用于在给定带权图中找出**任意两顶点之间**的最短路径长度（多源最短路径）。它采用“逐步增加允许中转顶点”的动态规划策略，将求任意两点最短路的问题划分为多个阶段来解决。对于一个有 $n$ 个顶点的图，Floyd 算法会进行 $n$ 个阶段：第 $k$ 阶段考虑允许使用前 $k$ 个顶点作为中转，其状态转移方程为：

$**若**\ dist[i][j] > dist[i][k] + dist[k][j]，**则**\ dist[i][j] = dist[i][k] + dist[k][j]:contentReference[oaicite:17]{index=17}.$

简言之，在第 $k$ 阶段，算法判断是否经由第 $k$ 个顶点可以使 $i$ 到 $j$ 的路径更短，如果是则进行更新。经过 $n$ 个阶段后，所有顶点对之间的最短路长都被正确计算出来。除了距离矩阵 `dist[][]` 外，Floyd 算法有时还维护一个 `path[][]` 矩阵用于记录对应最短路径的中转顶点（便于还原路径）。

- **适用场景：\**Floyd 算法适用于\**求解多源最短路径**问题，一次运行即可得到所有点对的最短距离。通常用于**顶点规模较小但需要频繁查询**最短路的情况（例如路由规划中预先计算所有城市间最短路）。由于算法复杂度较高（$O(n^3)$），对于**稠密图**或 $n$ 不太大的图较为合适。Floyd 算法可以处理**正权或负权**（但没有负权回路）的图，相比之下对**负权边**比 Dijkstra 更加宽容。
- **典型考点：\**本算法属于 408 考试中\**图的最短路径**知识点。常见考查形式包括：给定一个邻接矩阵，让考生执行一轮或全部 Floyd 算法迭代并写出结果矩阵；理解 Floyd 动态规划转移公式；比较 Floyd 与 Dijkstra 算法的异同（如一个是多源DP，一个是单源贪心）。由于 Floyd 实现简单，偶尔选择题会考其时间复杂度 $O(n^3)$。

（此处可插图表示 Floyd 算法对距离矩阵的反复松弛更新过程，如 3 重循环更新示意）

### 算法步骤（伪代码实现）

Floyd-Warshall 算法通常以邻接矩阵作为初始输入。设 `dist[i][j]` 表示顶点 $i$ 到顶点 $j$ 的当前最短路径长度（初始化为直接边权或 $\infty$）。算法主要包含三重循环：

```
// 初始化 dist 矩阵
for (i = 1..n):
    for (j = 1..n):
        if (i == j) dist[i][j] = 0;
        else if (存在边 i->j) dist[i][j] = w(i,j);
        else dist[i][j] = INF;

// 主算法三重循环
for (k = 1; k <= n; ++k) {             // 允许中转的顶点编号从1到n
    for (i = 1; i <= n; ++i) {
        for (j = 1; j <= n; ++j) {
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
                dist[i][j] = dist[i][k] + dist[k][j];
                // 可选: 记录中转点 k 到 path[i][j]
            }
        }
    }
}
```

算法结束后，`dist[i][j]` 即为顶点 $i$ 到 $j$ 的最短路径权重。如果需要路径具体序列，可根据 `path[][]` 记录的中转信息递归回溯还原。

### 算法复杂度

- **时间复杂度：**$O(n^3)$，由于有三个嵌套循环遍历所有顶点对组合。对于规模较大的图，该算法非常耗时，因此常用于 $n$ 在几百以内的情况。
- **空间复杂度：**$O(n^2)$，需要存储距离矩阵和（可选的）路径中转矩阵。

相比多次运行单源算法求所有点对最短路（例如对每个源点跑一次 Dijkstra，总复杂度 $O(n \times (m \log n))$），当图较稠密时 Floyd 算法更高效且编程更简单；但当图稀疏且 $n$ 较大时，多次 Dijkstra 通常更快。

### 典型考点摘要

- **手算矩阵更新：**考研可能要求考生完成 Floyd 算法对给定小规模图的计算，考生应掌握算法每阶段如何更新距离矩阵的过程。可按阶段画表格：初始距离矩阵、加入中转点 $k=1$ 后的新矩阵…直到 $k=n$ 的最终矩阵。理解判断条件 `dist[i][j] > dist[i][k] + dist[k][j]` 何时触发更新，是解题关键。
- **比较算法差异：**需理解 Floyd 算法与 Dijkstra 等单源算法的区别：Floyd 算法一次性计算多源结果，利用动态规划思想以顶点为中转更新矩阵；而 Dijkstra 每次仅确定一个源的最近节点，逐步扩展路径。Floyd 的优点是实现简单且结果全面，但代价是 $O(n^3)$ 时间开销。经典考题会问哪种情况下适合用 Floyd。一般来说，**当图需要频繁查询任意两点最短路且顶点不太多时**，Floyd 是合适的选择。

## 拓扑排序（AOV 网）

> **我的理解：\**拓扑排序其实就是在\**有向无环图**(DAG)中按照依赖关系排定任务顺序——每次找出一个没有前驱（依赖）的节点输出，并移除它再继续，直到所有节点都有了先后次序。

### 基本概念与定义

**拓扑排序**是针对**有向无环图（DAG）\**的一种顶点线性排序方式。如果一个有向图存在环路，则不存在拓扑序列；反之，DAG 至少有一种拓扑排序结果。形式化地说，拓扑排序产生一个包含图中所有顶点的序列，并满足：若在原图中存在一条从顶点 A 到顶点 B 的路径，那么在拓扑序列中 A 必须排在 B 之前。也就是说，拓扑序列尊重了图中的部分顺序关系，没有任何一条有向边指向\**逆序**的顶点对。

拓扑排序常用来解决**依赖调度**问题。在所谓 **AOV网**（Activity On Vertex Network）模型中，我们用**顶点表示活动**，用有向边表示活动间的**先后依赖关系**。例如“课题项目管理”中各任务的依赖关系就可建模为 AOV 网，此时拓扑排序给出的一种顶点执行序列就是满足先决条件的任务安排顺序。

- **判定有无环：**如果对一个有向图执行拓扑排序，过程中发现无法找到无前驱顶点而仍有未输出的顶点，则说明图中存在环。这一点可用来检测循环依赖。
- **典型考点：\**拓扑排序属于考研408数据结构\**图的基本运算**。考试经常会给出一个表示前后依赖的有向图或描述，让考生给出**一种拓扑排序序列**（如果有多种答案取其中一种即可），或判断图中是否存在环路。要点是熟练掌握拓扑排序的实现方法（如**入度法**或 DFS 法)以及能够按照步骤手动模拟。尤其是入度法（Kahn 算法）每轮选取入度为0顶点的过程是重点。偶尔也会考查拓扑排序在实践中的应用，如判断某一调度顺序是否合法等。

（此处可插入拓扑排序的示意图，例如“番茄炒蛋”的步骤依赖图及其拓扑序列）

### 拓扑排序的实现思路

拓扑排序有两种典型实现：**基于入度的算法** 和 **基于 DFS 的算法**。以下主要介绍常用的入度法（Kahn 算法）步骤：

1. **计算入度：**统计图中每个顶点的入度（即有多少条前驱边）。可以遍历邻接表/邻接矩阵完成。将所有入度为 0 的顶点收集到一个队列中。
2. **输出入度为0的顶点：**反复从队列中取出一个入度为0的顶点，将其输出到拓扑序列中；然后删除该顶点以及从它出发的所有有向边。每删除一条边，都相应减少目标顶点的入度，如果某个目标顶点入度因而减为0，则将其加入队列。
3. **循环上述过程：**直到队列为空为止。若输出的顶点数少于图中顶点总数，说明剩余顶点都有前驱（入度不为0），即图中存在环路，**无拓扑排序**；否则输出序列即为其中一种拓扑排序结果。

下面给出入度法的简洁伪代码实现：

```
// 计算入度
int indegree[n] = {0};
for (每条有向边 (u->v) ):
    indegree[v]++;

// 初始化队列
queue<int> Q;
for (v=0; v<n; ++v) {
    if (indegree[v] == 0) Q.push(v);
}

// 拓扑排序
vector<int> topo;
while (!Q.empty()) {
    int u = Q.front();
    Q.pop();
    topo.push_back(u);
    for (每条从 u 出发的边 u->w):
        indegree[w]--;
        if (indegree[w] == 0) Q.push(w);
}

// 检查有无环
if (topo.size() < n) 
    cout << "Graph has a cycle, no topological order.\n";
else 
    cout << "One Topological Order: " << topo;
```

**算法复杂度：**由于每条边和顶点都只被处理一次，拓扑排序运行在 **$O(n + m)$** 时间，其中 $n$ 是顶点数，$m$ 是边数。空间复杂度为 $O(n)$（需存储若干辅助数组和队列）。

### 拓扑排序的结果性质

- **非唯一性：**一个有向无环图可能有多个不同的拓扑序列。只要不违反先序约束，顶点的相对次序可以灵活变动。当图结构比较松散时，拓扑排序结果的选择往往更多。考试中只需给出任意一种合法序列。
- **应用延伸：**拓扑排序结果并非唯一，但所有结果都有一个共同点：如果顶点 A 是顶点 B 的前置依赖，则 A 一定在 B 之前。这一特性确保了排序的正确性。在工程管理中，拓扑序列可用于确定任务的线性执行顺序；在编译技术中，拓扑排序用于解析源代码模块的依赖关系（如编译顺序）。
- **典型考点：\**要求考生列出具体实例的拓扑排序步骤。例如常见的“洗菜炒菜”步骤图，考生需要每轮找出无前驱的任务（如“买菜”“打鸡蛋”等），依次给出任务执行顺序。也可能要求说明如果某一步骤无法找到无前驱节点，就可判断存在循环依赖。掌握\**AOV 网**模型的定义和拓扑排序的判定方法即可应对。

## 关键路径算法（AOE 网）

> **我的理解：\**关键路径算法针对\**有向无环的活动网络（AOE网）**，通过计算各事件的最早和最迟发生时间，找出那些**没有时间余量**的活动所构成的路径，这条路径决定了工程的工期长短，是整个项目进度的瓶颈。

### 背景与定义

在许多工程计划与调度问题中，我们关心完成整个工程所需的**最短时间**以及哪些任务对工期有直接影响。**关键路径法（Critical Path Method, CPM）\**正是为此设计的一种算法。它以 \*\*AOE 网\*\* 为模型：AOE (Activity On Edge) 网是一个\**带权有向无环图**，其中**顶点表示事件**（某阶段的开始或结束），**有向边表示活动**（需要消耗时间的任务），边上的权重为该活动所需的时间或资源。通常，AOE 网中有一个入度为0的**开始顶点（源点）\**和一个出度为0的\**结束顶点（汇点）**，分别代表工程的开始和结束。

**关键路径**是指在 AOE 网中，由一系列**关键活动**连接而成的从源点到汇点的路径。关键活动指那些**最早开始时间和最迟开始时间相等**（没有富余/机动时间）的活动。如果某个关键活动延迟，将直接导致整个工程完工时间的延迟。因此，关键路径上的所有活动决定了工程的最短完工时间，其总持续时间就是工程工期。工程中可能存在不止一条关键路径；只有将所有关键路径上的活动都按期完成，才能保证工期不被延误。

- **典型考点：\**关键路径算法属于408考研中数据结构图论的\**应用算法**部分，常以工程项目进度网络图为背景考查。考题通常给出一个小型 AOE 网，要求考生计算**各事件的最早发生时间 $ve$ 和最迟发生时间 $vl$**，确定关键路径以及工程的最短完成时间。例如某年试题可能给出几个活动及其持续时间，考生需要画出表格依拓扑序列算出 $ve$、$vl$ 再标出关键活动。掌握公式推导和手算步骤是得分关键。

（此处可插入关键路径分析图，如某工程活动网络，标注各事件时间及关键路径高亮）

### 算法思路

关键路径算法可分为两个阶段，均基于对**AOE 网的拓扑排序**：

1. **正向计算事件最早发生时间 $ve$:** 从源点出发，按拓扑序列依次计算每个事件的最早发生时间。初始时源点 $ve(\text{源})=0$。对拓扑序列中的每个事件 $k$，其最早时间由所有前驱事件的 $ve$ 加上对应活动持续时间的最大值决定：
    $ve(k) = \max\{\,ve(j) + w(j,k)\,\mid\, \forall \text{前驱事件 } j \text{ 到 } k\}:contentReference[oaicite:38]{index=38}:contentReference[oaicite:39]{index=39}.$
    这样计算到汇点时，得到的 $ve(\text{汇})$ 即为工程的最短完成时间。
2. **反向计算事件最迟发生时间 $vl$:** 将汇点的最迟发生时间初始设为 $vl(\text{汇}) = ve(\text{汇})$（工程最短工期）。然后按拓扑序的**逆序**遍历各事件，计算每个事件的最迟发生时间：对每个事件 $k$，其后继事件集合为 $\text{Succ}(k)$，则
    $vl(k) = \min\{\,vl(j) - w(k,j)\,\mid\, \forall \text{后继事件 } j \in \text{Succ}(k)\}:contentReference[oaicite:41]{index=41}.$
    源点的 $vl(\text{源})$ 计算完毕后，应等于 $0$；若不为0说明网络中计算有误或存在问题。

完成以上两步，我们即可找出**关键活动和关键路径**：

- 对于每条活动边 $(i \rightarrow j)$，计算该活动的**最早开始时间** $e = ve(i)$，**最迟开始时间** $l = vl(j) - w(i,j)$。它们之差 $l - e$ 即为该活动的**时差（机动时间）**。若 $l - e = 0$，则此活动为关键活动。
- 将源点到汇点之间由关键活动串连成的路径标出，即得到一条关键路径。如有多条关键路径，应全部给出。

### 算法实现（伪代码）

根据上述思路，可将关键路径算法实现如下（假设拓扑序列已求得存于数组 `Topo[]` 中）：

```
// 正向阶段：计算 ve[]
for (每个顶点 u in Topo 顺序):
    ve[u] = 0;
for (每个顶点 u in Topo 顺序):
    for (每条边 u->v):
        if (ve[u] + w(u,v) > ve[v]):
            ve[v] = ve[u] + w(u,v);

// 此时 ve[终点] 为工程最早完成时间
// 反向阶段：计算 vl[]
int end = 汇点; 
for (每个顶点 v):
    vl[v] = ve[end];           // 初始化所有 vl 为汇点时间
// 逆拓扑序计算 vl
for (每个顶点 u in Topo 逆序):
    for (每条边 u->v):
        if (vl[v] - w(u,v) < vl[u]):
            vl[u] = vl[v] - w(u,v);

// 识别关键活动
vector<Edge> criticalEdges;
for (每条边 u->v 权重 d):
    int e = ve[u];
    int l = vl[v] - d;
    if (e == l) {
        criticalEdges.push_back(Edge(u,v));
    }
}
```

在获得关键活动集合后，可根据它们连接成的路径输出关键路径。上述算法复杂度为 **$O(n + m)$**（与拓扑排序同阶），适用于工程任务量较大的项目计划分析。

### 典型考点摘要

- **公式应用：**掌握 $ve$ 和 $vl$ 的计算公式及推导顺序是关键。正向推导取前驱最大和，反向推导取后继最小和，很多考生在反向计算 $vl$ 时容易弄错求最小值的对象，需特别注意公式中的后继集合。考试中常给出活动列表要求填表计算 $ve$、$vl$。建议写出每个顶点的 $ve$、$vl$ 计算过程以确保不漏。
- **关键活动判定：**确定关键活动通常考查计算其机动时间是否为0。一旦找到所有机动时间为0的活动，按照它们连接的顺序列出路径即可。如某年试题给出活动及持续时间，让考生算出关键路径长度并列举关键活动。例如，在上图示例中，若计算得关键活动为 {a2, a5, a7}，对应关键路径可能是 V1→V3→V4→V6。回答时要写明总工期（关键路径长度）以及关键路径上的活动序列。
- **工程调整决策：**理解关键路径的性质：如果要缩短工期，必须压缩关键路径上的活动时间；非关键活动有富余时间，适度延迟不会影响总工期。这些性质在选择题中可能出现判断正误。也可能给出一个网络问如果某活动延迟x天工期如何变化，这需要判断该活动是否在关键路径上。熟悉关键路径的定义和特性即可从容应对。

